%% Channel Decoder
% it uses soft input i.e. LLRs of the symbols
% ChCode: a structure contains information about CMS generated by
% 'GenerateCode.m'
% data a vector of demodulated data, Esno is the Es/No ratio of each symbol
function [ bits_e, encoded_bits_e ] = Decoder( ChCode, data_e, Esno, h)

constellation = ChCode.Constellation;
Nb = ChCode.Nb;
Ncbpsym = ChCode.Ncbpsym;
% Symbol to bits LLR mapping
if nargin < 4
    LLRs_symb  = Demod2D(data_e.',constellation, Esno.');
else
    LLRs_symb  = Demod2D(data_e.',constellation, Esno.', h.');
end
%LLRs_symb = LLRs_symb -repmat(max(LLRs_symb,[],1),2^bps,1);
% convert symbols LLRs to bits LLRs

llrs_dem  = Somap(LLRs_symb, ChCode.demod_type);
encoded_bits_e = llrs_dem' > 0;
llrs_dem  = reshape(llrs_dem,Ncbpsym,Nb);
% Deinterleaving
llrs_dem(ChCode.interleaver1,:) = llrs_dem;
llrs_un_dec = zeros(1,length(ChCode.punc_flg));
llrs_un_dec(ChCode.punc_flg == 1) = llrs_dem;
cnst = size(ChCode.g,2)-1;

llrs_un_dec = llrs_un_dec(1:(ChCode.Nr_infobits+cnst)*2);
if ChCode.Alg == 0 %CC encoder
bits_e = ViterbiDecode(llrs_un_dec, ChCode.g, ChCode.nsc_flag);
elseif ChCode.Alg == 1 % turbo encoder
    g1 = ChCode.Turbo_g; %13 15
    g2 = g1; %13 15
    nsc_flag1 = ChCode.Turbo_nsc_flag ;
    nsc_flag2 = nsc_flag1;
    pun_pattern = ChCode.Turbo_pun_pattern; % rate 1/2;
    tail_pattern = ChCode.Turbo_tail_pattern;
    interleaver = ChCode.Turbo_interleaver;   
    bits_e = TurboDecode( llrs_un_dec, ChCode.info_bits.', ChCode.number_itr, ChCode.decoder_type,  interleaver, pun_pattern, tail_pattern, g1, nsc_flag1, g2, nsc_flag2 );      
end
bits_e = bits_e.';
end

